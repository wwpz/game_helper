# 重新设计模拟器操作架构方案

## 1. 概述

基于现有 [simulatorUtil](file:///F:/me/StarRailHelper/utils/simulator_util.py#L33-L1070) 类存在的问题和多线程使用需求，本文档提出一套全新的模拟器操作架构设计方案。该方案旨在解决当前架构中的问题，提供更好的可维护性、可扩展性和线程安全性。

## 2. 当前架构问题分析

### 2.1 单一职责违反
[simulatorUtil](file:///F:/me/StarRailHelper/utils/simulator_util.py#L33-L1070) 类承担了过多职责，包括：
- ADB 命令执行
- 图像处理和匹配
- OCR 处理
- 模拟器控制
- UI 元素识别和交互

### 2.2 线程安全性问题
- 类不是线程安全的
- 多个线程共享实例会导致不可预测的结果

### 2.3 紧耦合设计
- 各功能模块之间高度耦合
- 难以单独测试和维护

### 2.4 命名和代码规范问题
- 类名和方法名不符合 Python 命名规范
- 存在重复代码

## 3. 重新设计方案

### 3.1 核心设计原则
1. **单一职责原则**：每个类只负责一个明确的功能领域
2. **依赖注入**：通过构造函数注入依赖，提高可测试性
3. **线程安全**：确保多线程环境下的正确性
4. **可扩展性**：易于添加新功能和适配不同模拟器
5. **符合命名规范**：遵循 Python 命名约定

### 3.2 新架构类图

```
                            +------------------+
                            |   SimulatorBase  |
                            |   <<abstract>>   |
                            +------------------+
                                     ^
                                     |
                    +---------------------------------+
                    |                                 |
          +------------------+            +----------------------+
          |  ADBSimulator    |            |  Win32Simulator      |
          +------------------+            +----------------------+
          | - port           |            | - window_name        |
          | - host           |            | - window_class       |
          | - adb_path       |            | - simulator_path     |
          +------------------+            +----------------------+
                     ^                              ^
                     |                              |
        +-------------------------+    +--------------------------+
        |   MuMuSimulator         |    |   BlueStacksSimulator    |
        +-------------------------+    +--------------------------+

        +------------------+     +------------------+     +------------------+
        |   ADBController  |     | ImageProcessor   |     |   OCRProcessor   |
        +------------------+     +------------------+     +------------------+
        | + tap()          |     | + match()        |     | + recognize()    |
        | + swipe()        |     | + crop()         |     | + find_text()    |
        | + screencap()    |     | + enhance()      |     | + click_text()   |
        | + connect()      |     +------------------+     +------------------+
        | + disconnect()   |
        +------------------+

        +------------------+     +------------------+     +------------------+
        | UIElementLocator |     |   TaskExecutor   |     |   GameAdapter    |
        +------------------+     +------------------+     +------------------+
        | + find_element() |     | + execute_task() |     | + launch_game()  |
        | + wait_element() |     | + perform_action()|    | + login()        |
        | + click_element()|     +------------------+     | + run_daily()    |
        +------------------+                              +------------------+
                |                                                   |
                +-------------------> [GameService] <---------------+
                                   +------------------+
                                   | + login()        |
                                   | + do_daily_task()|
                                   | + cultivate()    |
                                   | + fight()        |
                                   +------------------+
```

### 3.3 核心类设计

#### 3.3.1 模拟器基类 (SimulatorBase)
```python
from abc import ABC, abstractmethod

class SimulatorBase(ABC):
    """模拟器基类"""
    
    @abstractmethod
    def start(self) -> bool:
        """启动模拟器"""
        pass
    
    @abstractmethod
    def stop(self) -> bool:
        """停止模拟器"""
        pass
    
    @abstractmethod
    def is_running(self) -> bool:
        """检查模拟器是否运行中"""
        pass
    
    @abstractmethod
    def connect(self) -> bool:
        """连接到模拟器"""
        pass
    
    @abstractmethod
    def disconnect(self) -> bool:
        """断开连接"""
        pass
```

#### 3.3.2 ADB控制器 (ADBController)
```python
import subprocess
import threading
from typing import Optional

class ADBController:
    """ADB控制器，线程安全"""
    
    _instances = {}
    _lock = threading.Lock()
    
    def __init__(self, host: str = "127.0.0.1", port: int = 5037):
        self.host = host
        self.port = port
        self.device_serial = f"{host}:{port}"
        self._connection_lock = threading.Lock()
    
    @classmethod
    def get_instance(cls, host: str = "127.0.0.1", port: int = 5037):
        """获取ADB控制器实例（单例模式）"""
        key = f"{host}:{port}"
        with cls._lock:
            if key not in cls._instances:
                cls._instances[key] = cls(host, port)
            return cls._instances[key]
    
    def connect_device(self, device_port: int) -> bool:
        """连接到指定端口的设备"""
        with self._connection_lock:
            try:
                cmd = ["adb", "connect", f"{self.host}:{device_port}"]
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)
                return "connected" in result.stdout.lower() or "already" in result.stdout.lower()
            except Exception:
                return False
    
    def disconnect_device(self, device_port: int) -> bool:
        """断开指定端口的设备"""
        try:
            cmd = ["adb", "disconnect", f"{self.host}:{device_port}"]
            subprocess.run(cmd, capture_output=True, text=True, timeout=10)
            return True
        except Exception:
            return False
    
    def tap(self, x: int, y: int, device_port: int) -> bool:
        """点击屏幕"""
        try:
            cmd = ["adb", "-s", f"{self.host}:{device_port}", "shell", "input", "tap", str(x), str(y)]
            subprocess.run(cmd, capture_output=True, timeout=5)
            return True
        except Exception:
            return False
    
    def swipe(self, x1: int, y1: int, x2: int, y2: int, duration: int = 500, device_port: int) -> bool:
        """滑动屏幕"""
        try:
            cmd = ["adb", "-s", f"{self.host}:{device_port}", "shell", "input", "swipe", 
                   str(x1), str(y1), str(x2), str(y2), str(duration)]
            subprocess.run(cmd, capture_output=True, timeout=10)
            return True
        except Exception:
            return False
    
    def screencap(self, device_port: int) -> Optional[bytes]:
        """截图"""
        try:
            cmd = ["adb", "-s", f"{self.host}:{device_port}", "shell", "screencap", "-p"]
            result = subprocess.run(cmd, capture_output=True, timeout=10)
            return result.stdout
        except Exception:
            return None
```

#### 3.3.3 图像处理器 (ImageProcessor)
```python
import cv2
import numpy as np
from typing import Optional, Tuple

class ImageProcessor:
    """图像处理器"""
    
    def __init__(self):
        self._template_cache = {}
    
    def match_template(self, screenshot: np.ndarray, template_path: str, 
                      threshold: float = 0.8) -> Optional[Tuple[int, int, float]]:
        """模板匹配"""
        # 实现模板匹配逻辑
        pass
    
    def crop_image(self, image: np.ndarray, region) -> np.ndarray:
        """裁剪图像"""
        # 实现图像裁剪逻辑
        pass
    
    def enhance_image(self, image: np.ndarray) -> np.ndarray:
        """增强图像"""
        # 实现图像增强逻辑
        pass
```

#### 3.3.4 OCR处理器 (OCRProcessor)
```python
from typing import Dict, List, Optional, Tuple

class OCRProcessor:
    """OCR处理器"""
    
    def __init__(self, ocr_engine):
        self.ocr_engine = ocr_engine
    
    def recognize(self, image_bytes: bytes) -> Dict:
        """识别图像中的文本"""
        return self.ocr_engine.runBytes(image_bytes)
    
    def find_text_position(self, ocr_result: Dict, text: str, 
                          exact_match: bool = True) -> Optional[Tuple[int, int]]:
        """查找文本位置"""
        # 实现文本位置查找逻辑
        pass
    
    def click_text(self, ocr_result: Dict, text: str, device_port: int, 
                  adb_controller: ADBController, exact_match: bool = True) -> bool:
        """点击文本"""
        # 实现点击文本逻辑
        pass
```

#### 3.3.5 模拟器实例管理器 (SimulatorManager)
```python
import threading
from typing import Dict

class SimulatorManager:
    """模拟器实例管理器，线程安全"""
    
    _instances: Dict[str, 'SimulatorInstance'] = {}
    _lock = threading.Lock()
    
    @classmethod
    def get_simulator_instance(cls, port: int, account: str = "") -> 'SimulatorInstance':
        """获取模拟器实例"""
        thread_id = threading.get_ident()
        key = f"{port}_{thread_id}_{account}"
        
        with cls._lock:
            if key not in cls._instances:
                cls._instances[key] = SimulatorInstance(port, account)
            return cls._instances[key]
    
    @classmethod
    def release_simulator_instance(cls, port: int, account: str = ""):
        """释放模拟器实例"""
        thread_id = threading.get_ident()
        key = f"{port}_{thread_id}_{account}"
        
        with cls._lock:
            if key in cls._instances:
                # 清理资源
                cls._instances[key].cleanup()
                del cls._instances[key]

class SimulatorInstance:
    """模拟器实例，每个线程独立"""
    
    def __init__(self, port: int, account: str = ""):
        self.port = port
        self.account = account
        self.adb = ADBController.get_instance()
        self.image_processor = ImageProcessor()
        self.ocr_processor = None  # 需要外部注入
        
        # 连接到设备
        self.adb.connect_device(port)
    
    def cleanup(self):
        """清理资源"""
        self.adb.disconnect_device(self.port)
```

#### 3.3.6 游戏适配器 (GameAdapter)
```python
from abc import ABC, abstractmethod

class GameAdapter(ABC):
    """游戏适配器基类"""
    
    def __init__(self, port: int, account: str):
        self.port = port
        self.account = account
        self.simulator = SimulatorManager.get_simulator_instance(port, account)
    
    @abstractmethod
    def launch_game(self) -> bool:
        """启动游戏"""
        pass
    
    @abstractmethod
    def login(self) -> bool:
        """登录游戏"""
        pass
    
    @abstractmethod
    def execute_task(self, task_name: str) -> bool:
        """执行任务"""
        pass
    
    def __del__(self):
        """析构时释放资源"""
        SimulatorManager.release_simulator_instance(self.port, self.account)
```

#### 3.3.7 星穹铁道适配器 (StarRailAdapter)
```python
from core.log.log_factory import get_logger

class StarRailAdapter(GameAdapter):
    """星穹铁道适配器"""
    
    def __init__(self, port: int, account: str):
        super().__init__(port, account)
        self.log = get_logger("StarRailAdapter", account)
    
    def launch_game(self) -> bool:
        """启动游戏"""
        self.log.info(f"正在启动游戏，端口: {self.port}，账号: {self.account}")
        # 实现启动游戏逻辑
        return True
    
    def login(self) -> bool:
        """登录游戏"""
        self.log.info(f"正在登录游戏，端口: {self.port}，账号: {self.account}")
        # 通过服务类执行登录
        service = StarRailGameService(self.simulator)
        return service.login()
    
    def execute_task(self, task_name: str) -> bool:
        """执行任务"""
        self.log.info(f"正在执行任务: {task_name}，端口: {self.port}，账号: {self.account}")
        service = StarRailGameService(self.simulator)
        
        if task_name == "daily":
            return service.do_daily_task()
        elif task_name == "cultivate":
            return service.cultivate()
        elif task_name == "fight":
            return service.fight()
        else:
            self.log.warning(f"未知任务: {task_name}")
            return False
```

#### 3.3.8 游戏服务类 (GameService)
```python
class StarRailGameService:
    """星穹铁道游戏服务类"""
    
    def __init__(self, simulator_instance):
        self.simulator = simulator_instance
        self.adb = simulator_instance.adb
        self.image_processor = simulator_instance.image_processor
        self.ocr_processor = simulator_instance.ocr_processor
    
    def login(self) -> bool:
        """登录"""
        # 实现登录逻辑
        return True
    
    def do_daily_task(self) -> bool:
        """执行日常任务"""
        # 实现日常任务逻辑
        return True
    
    def cultivate(self) -> bool:
        """执行培养"""
        # 实现培养逻辑
        return True
    
    def fight(self) -> bool:
        """执行战斗"""
        # 实现战斗逻辑
        return True
```

### 3.4 多线程使用示例

```python
import threading
import time

def worker_thread(port: int, account: str):
    """工作线程"""
    try:
        # 创建适配器
        adapter = StarRailAdapter(port, account)
        
        # 执行任务
        adapter.launch_game()
        adapter.login()
        adapter.execute_task("daily")
        adapter.execute_task("cultivate")
        
        print(f"账户 {account} 任务执行完成")
        
    except Exception as e:
        print(f"处理账户 {account} 时出错: {e}")
    finally:
        # 资源会自动释放（通过析构函数）

def main():
    """主函数"""
    # 账户配置
    configs = [
        {"port": 16384, "account": "account1"},
        {"port": 16484, "account": "account2"},
        {"port": 16584, "account": "account3"},
    ]
    
    # 创建并启动线程
    threads = []
    for config in configs:
        thread = threading.Thread(target=worker_thread, kwargs=config)
        threads.append(thread)
        thread.start()
        time.sleep(1)  # 避免同时启动冲突
    
    # 等待所有线程完成
    for thread in threads:
        thread.join()
    
    print("所有任务执行完成")

if __name__ == "__main__":
    main()
```

## 4. 优势分析

### 4.1 架构优势
1. **职责清晰**：每个类都有明确的职责
2. **松耦合**：组件之间依赖关系清晰
3. **易测试**：每个组件可以独立测试
4. **易扩展**：添加新功能不影响现有代码

### 4.2 多线程优势
1. **线程安全**：通过实例隔离保证线程安全
2. **资源管理**：自动管理资源生命周期
3. **性能优化**：避免重复创建和销毁对象

### 4.3 维护优势
1. **代码复用**：组件可复用到其他项目
2. **易于调试**：问题定位更准确
3. **文档友好**：结构清晰，易于理解

## 5. 迁移策略

### 5.1 渐进式迁移
1. 先实现新架构的核心组件
2. 逐步替换原有功能
3. 保持向后兼容
4. 最终移除旧代码

### 5.2 兼容层设计
```python
class SimulatorUtilAdapter:
    """旧接口适配器，保持向后兼容"""
    
    def __init__(self, window_name, window_class, simulator_path, port, ocr):
        self.simulator = SimulatorManager.get_simulator_instance(port)
        # 适配原有接口方法
```

## 6. 总结

这套重新设计的架构方案解决了原有 [simulatorUtil](file:///F:/me/StarRailHelper/utils/simulator_util.py#L33-L1070) 类存在的各种问题，提供了更好的可维护性、可扩展性和线程安全性。通过职责分离、依赖注入和线程安全设计，使得整个系统更加健壮和易于维护。